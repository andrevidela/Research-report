
@inproceedings{turner1995once,
  title={Once upon a type},
  author={Turner, David N and Wadler, Philip and Mossin, Christian},
  booktitle={Proceedings of the seventh international conference on Functional programming languages and computer architecture},
  pages={1--11},
  year={1995}
}
@inproceedings{wadler1990linear,
  title={Linear types can change the world!},
  author={Wadler, Philip},
  booktitle={Programming concepts and methods},
  volume={3},
  number={4},
  pages={5},
  year={1990},
  organization={Citeseer}
}
@inproceedings{wadler1988deforestation,
  title={Deforestation: Transforming programs to eliminate trees},
  author={Wadler, Philip},
  booktitle={European Symposium on Programming},
  pages={344--358},
  year={1988},
  organization={Springer}
}
@inproceedings{girard1987theoretical,
  title={Theoretical computer science},
  author={Girard, Jean-Yves},
  booktitle={Linear logic},
  volume={50},
  pages={1--102},
  year={1987}
}
@article{girard1992bounded,
  title={Bounded linear logic: a modular approach to polynomial-time computability},
  author={Girard, Jean-Yves and Scedrov, Andre and Scott, Philip J},
  journal={Theoretical computer science},
  volume={97},
  number={1},
  pages={1--66},
  year={1992},
  publisher={Elsevier}
}
@inproceedings{ott, title={Towards observational type theory}, abstractNote={Observational Type Theory (OTT) combines beneficial aspects of Intensional and Extensional Type Theory (ITT/ETT). It separates definitional equality, decidable as in ITT, and a substitutive propositional equality, capturing extensional equality of functions, as in ETT. Moreover, canonicity holds: any closed term is definitionally reducible to a canonical value. Building on previous work by each author, this article reports substantial progress in the form of a simplified theory with a straightforward syntactic presentation, which we have implemented. As well as simplifying reasoning about functions, OTT offers potential foundational benefits, e.g. it gives rise to a closed type theory encoding inductive datatypes. 1.}, booktitle={In preparation}, author={Altenkirch, Thorsten and Mcbride, Conor}, year={2006} }
 @inproceedings{qtt, place={Oxford, United Kingdom}, series={LICS ’18}, title={Syntax and Semantics of Quantitative Type Theory}, ISBN={978-1-4503-5583-4}, url={https://doi.org/10.1145/3209108.3209189}, DOI={10.1145/3209108.3209189}, abstractNote={We present Quantitative Type Theory, a Type Theory that records usage information for each variable in a judgement, based on a previous system by McBride. The usage information is used to give a realizability semantics using a variant of Linear Combinatory Algebras, refining the usual realizability semantics of Type Theory by accurately tracking resource behaviour. We define the semantics in terms of Quantitative Categories with Families, a novel extension of Categories with Families for modelling resource sensitive type theories.}, booktitle={Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science}, publisher={Association for Computing Machinery}, author={Atkey, Robert}, year={2018}, month={Jul}, pages={56–65}, collection={LICS ’18} }
 @article{linear_haskell, title={Linear Haskell: practical linearity in a higher-order polymorphic language}, url={https://doi.org/10.1145/3158093}, abstractNote={Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as OCaml or Haskell. In this paper, we study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear functions can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values. To demonstrate the efficacy of our linear type system — both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write programs with linear types — we implemented our type system in ghc, the leading Haskell compiler, and demonstrate two kinds of applications of linear types: mutable data with pure interfaces; and enforcing protocols in I/O-performing functions.}, publisher={Association for Computing Machinery}, author={Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud}, year={2017}, month={Dec} }
 @article{Brady_2013, title={Idris, a general-purpose dependently typed programming language: Design and implementation}, volume={23}, ISSN={0956-7968, 1469-7653}, DOI={10.1017/S095679681300018X}, abstractNote={Many components of a dependently typed programming language are by now well understood, for example, the underlying type theory, type checking, unification and evaluation. How to combine these components into a realistic and usable high-level language is, however, folklore, discovered anew by successive language implementors. In this paper, I describe the implementation of Idris, a new dependently typed functional programming language. Idris is intended to be a general-purpose programming language and as such provides high-level concepts such as implicit syntax, type classes and do notation. I describe the high-level language and the underlying type theory, and present a tactic-based method for elaborating concrete high-level syntax with implicit arguments and type classes into a fully explicit type theory. Furthermore, I show how this method facilitates the implementation of new high-level language constructs.}, number={5}, journal={Journal of Functional Programming}, author={Brady, Edwin}, year={2013}, month={Sep}, pages={552–593} }
 @article{levitation, title={The gentle art of levitation}, url={https://doi.org/10.1145/1932681.1863547}, abstractNote={We present a closed dependent type theory whose inductive types are given not by a scheme for generative declarations, but by encoding in a universe. Each inductive datatype arises by interpreting its description - a first-class value in a datatype of descriptions. Moreover, the latter itself has a description. Datatype-generic programming thus becomes ordinary programming. We show some of the resulting generic operations and deploy them in particular, useful ways on the datatype of datatype descriptions itself. Simulations in existing systems suggest that this apparently self-supporting setup is achievable without paradox or infinite regress.}, publisher={Association for Computing Machinery}, author={Chapman, James and Dagand, Pierre-Évariste and McBride, Conor and Morris, Peter}, year={2010}, month={Sep} }
 @article{linear_ref_count, title={Reference counting as a computational interpretation of linear logic}, volume={6}, ISSN={1469-7653, 0956-7968}, DOI={10.1017/S0956796800001660}, abstractNote={We develop an operational model for a language based on linear logic. Our semantics is ‘low-level’ enough to express sharing and copying while still being ‘high-level’ enough to abstract away from details of memory layout, and thus can be used to test potential applications of linear logic for analysis of programs. In particular, we demonstrate a precise relationship between type correctness for the linear-logic-based language and the correctness of a reference-counting interpretation of the primitives, and formulate and prove a result describing the possible run-time reference counts of values of linear type.}, number={2}, journal={Journal of Functional Programming}, author={Chirimar, Jawahar and Gunter, Carl A. and Riecke, Jon G.}, year={1996}, month={Mar}, pages={195–244} }
 @inproceedings{hasochism, place={Boston, Massachusetts, USA}, series={Haskell ’13}, title={Hasochism: the pleasure and pain of dependently typed haskell programming}, ISBN={978-1-4503-2383-3}, url={https://doi.org/10.1145/2503778.2503786}, DOI={10.1145/2503778.2503786}, abstractNote={Haskell’s type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples---merge-sort and rectangular tilings---we show how to exploit Haskell’s constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.}, booktitle={Proceedings of the 2013 ACM SIGPLAN symposium on Haskell}, publisher={Association for Computing Machinery}, author={Lindley, Sam and McBride, Conor}, year={2013}, month={Sep}, pages={81–92}, collection={Haskell ’13} }
 @book{Martin-Lof, title={An intuitionistic theory of types}, abstractNote={An earlier, not yet conclusive, attempt at formulating a theory of this kind was made by Scott 1970. Also related, although less closely, are the type and logic free theories of constructions of Kreisel 1962 and 1965 and Goodman 1970. In its first version, the present theory was based on the strongly impredicative axiom that there is a type of all types whatsoever, which is at the same time a type and an object of that type. This axiom had to be abandoned, however, after it was shown to lead to a contradiction by Jean Yves Girard. I am very grateful to him for showing me his paradox. The change that it necessitated is so drastic that my theory no longer contains intuitionistic simple type theory as it originally did. Instead, its proof theoretic strength should be close to that of predicative analysis.}, author={Martin-Löf, Per} }
 @article{linear_inference, title={Modular Inference of Linear Types for Multiplicity-Annotated Arrows}, url={http://arxiv.org/abs/1911.00268}, abstractNote={Bernardy et al. [2018] proposed a linear type system $lambda^q_to$ as a core type system of Linear Haskell. In the system, linearity is represented by annotated arrow types $A to_m B$, where $m$ denotes the multiplicity of the argument. Thanks to this representation, existing non-linear code typechecks as it is, and newly written linear code can be used with existing non-linear code in many cases. However, little is known about the type inference of $lambda^q_to$. Although the Linear Haskell implementation is equipped with type inference, its algorithm has not been formalized, and the implementation often fails to infer principal types, especially for higher-order functions. In this paper, based on OutsideIn(X) [Vytiniotis et al., 2011], we propose an inference system for a rank 1 qualified-typed variant of $lambda^q_to$, which infers principal types. A technical challenge in this new setting is to deal with ambiguous types inferred by naive qualified typing. We address this ambiguity issue through quantifier elimination and demonstrate the effectiveness of the approach with examples.}, note={arXiv: 1911.00268}, journal={arXiv:1911.00268 [cs]}, author={Matsuda, Kazutaka}, year={2020}, month={Feb} }
 @article{mc_bride_zippers, title={Clowns to the left of me, jokers to the right (pearl): dissecting data structures}, url={https://doi.org/10.1145/1328897.1328474}, abstractNote={This paper introduces a small but useful generalisation to the “derivative” operation on datatypes underlying Huet’s notion of “zipper”, giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, “dissection”, turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right. I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet’s operations for navigating zippers. The original motivation for dissection was to define “division”, capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online and compiles with recent extensions to the Glasgow Haskell Compiler.}, publisher={Association for Computing Machinery}, author={McBride, Conor}, year={2008}, month={Jan} }
 @article{view_from_the_left, title={The view from the left}, volume={14}, ISSN={1469-7653, 0956-7968}, DOI={10.1017/S0956796803004829}, abstractNote={Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler’s (1987) notion of ‘view’. The programmer wishing to introduce a new view of a type $mathit{T}$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry–Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for $mathit{T}$. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.}, number={1}, journal={Journal of Functional Programming}, author={Mcbride, Conor and Mckinna, James}, year={2004}, month={Jan}, pages={69–111} }
 @article{granule, title={Quantitative program reasoning with graded modal types}, volume={3}, ISSN={2475-1421, 2475-1421}, DOI={10.1145/3341714}, number={ICFP}, journal={Proceedings of the ACM on Programming Languages}, author={Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley}, year={2019}, month={Jul}, pages={1–30} }
 @article{linear_types_update, title={Linear types can change the world!}, url={https://homepages.inf.ed.ac.uk/wadler/papers/linear/linear.ps}, author={Philip Wadler} }
 @article{propositions_as_sessions, title={Propositions as sessions}, url={https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions-jfp.pdf}, author={Philip Wadler} }
 @article{linear_types_subst , title={There is no substitute for linear logic}, url={https://homepages.inf.ed.ac.uk/wadler/papers/linearsub/linearsub.ps}, author={Philip Wadler} }
 @article{practical_affine, title={Practical affine types}, url={https://doi.org/10.1145/1925844.1926436}, abstractNote={Alms is a general-purpose programming language that supports practical affine types. To offer the expressiveness of Girard’s linear logic while keeping the type system light and convenient, Alms uses expressive kinds that minimize notation while maximizing polymorphism between affine and unlimited types. A key feature of Alms is the ability to introduce abstract affine types via ML-style signature ascription. In Alms, an interface can impose stiffer resource usage restrictions than the principal usage restrictions of its implementation. This form of sealing allows the type system to naturally and directly express a variety of resource management protocols from special-purpose type systems. We present two pieces of evidence to demonstrate the validity of our design goals. First, we introduce a prototype implementation of Alms and discuss our experience programming in the language. Second, we establish the soundness of the core language. We also use the core model to prove a principal kinding theorem.}, publisher={Association for Computing Machinery}, author={Tov, Jesse A. and Pucella, Riccardo}, year={2011}, month={Jan} }
 @article{immutable_beans, title={Counting Immutable Beans: Reference Counting Optimized for Purely Functional Programming}, url={http://arxiv.org/abs/1908.05647}, abstractNote={Most functional languages rely on some garbage collection for automatic memory management. They usually eschew reference counting in favor of a tracing garbage collector, which has less bookkeeping overhead at runtime. On the other hand, having an exact reference count of each value can enable optimizations, such as destructive updates. We explore these optimization opportunities in the context of an eager, purely functional programming language. We propose a new mechanism for efficiently reclaiming memory used by nonshared values, reducing stress on the global memory allocator. We describe an approach for minimizing the number of reference counts updates using borrowed references and a heuristic for automatically inferring borrow annotations. We implemented all these techniques in a new compiler for an eager and purely functional programming language with support for multi-threading. Our preliminary experimental results demonstrate our approach is competitive and often outperforms state-of-the-art compilers.}, note={arXiv: 1908.05647}, journal={arXiv:1908.05647 [cs]}, author={Ullrich, Sebastian and de Moura, Leonardo}, year={2020}, month={Mar} }
 @article{cubical_agda, title={Cubical agda: a dependently typed programming language with univalence and higher inductive types}, url={https://doi.org/10.1145/3341691}, abstractNote={Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.}, publisher={Association for Computing Machinery}, author={Vezzosi, Andrea and Mörtberg, Anders and Abel, Andreas}, year={2019}, month={Jul} }
 @article{linear_use, title={Is there a use for linear logic?}, url={https://doi.org/10.1145/115866.115894}, publisher={Association for Computing Machinery}, author={Wadler, Philip}, year={1991}, month={May} }
 @article{linear_races, url={https://wenkokke.github.io/pubs/coordination2019.pdf} }

