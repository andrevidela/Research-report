@inbook{category_of_containers, place={Berlin, Heidelberg}, series={Lecture Notes in Computer Science}, title={Categories of Containers}, volume={2620}, ISBN={978-3-540-00897-2}, url={http://link.springer.com/10.1007/3-540-36576-1_2}, DOI={10.1007/3-540-36576-1_2}, booktitle={Foundations of Software Science and Computation Structures}, publisher={Springer Berlin Heidelberg}, author={Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil}, editor={Gordon, Andrew D.}, year={2003}, pages={23–38}, collection={Lecture Notes in Computer Science} }
@article{delta_for_data, series={Fundamenta informaticae}, title={∂ for data: Differentiating data structures}, volume={65}, journal={IOS Press}, author={Abbott, Michael and Altenkirch, Thorsten and McBride, Conor and Ghani, Neil}, year={2005}, pages={1--28}, collection={Fundamenta informaticae} }
@phdthesis{practical_levitation, title={The Practical Guide to Levitation}, school={IT University Copenhagen}, author={Ahmad Salim Al-Sibahi}, year={2014}, month={Sep} }
@article{indexed_containers, title={Indexed containers}, volume={25}, ISSN={0956-7968, 1469-7653}, DOI={10.1017/S095679681500009X}, abstractNote={Abstract
           We show that the syntactically rich notion of strictly positive families can be reduced to a core type theory with a fixed number of type constructors exploiting the novel notion of indexed containers. As a result, we show indexed containers provide normal forms for strictly positive families in much the same way that containers provide normal forms for strictly positive types. Interestingly, this step from containers to indexed containers is achieved without having to extend the core type theory. Most of the construction presented here has been formalized using the Agda system.}, journal={Journal of Functional Programming}, author={Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and Mcbride, Conor and Morris, Peter}, year={2015}, pages={e5} }
@inproceedings{ott, title={Towards observational type theory}, abstractNote={Observational Type Theory (OTT) combines beneficial aspects of Intensional and Extensional Type Theory (ITT/ETT). It separates definitional equality, decidable as in ITT, and a substitutive propositional equality, capturing extensional equality of functions, as in ETT. Moreover, canonicity holds: any closed term is definitionally reducible to a canonical value. Building on previous work by each author, this article reports substantial progress in the form of a simplified theory with a straightforward syntactic presentation, which we have implemented. As well as simplifying reasoning about functions, OTT offers potential foundational benefits, e.g. it gives rise to a closed type theory encoding inductive datatypes. 1.}, booktitle={In preparation}, author={Altenkirch, Thorsten and Mcbride, Conor}, year={2006} }
@article{parameterised_computation, title={Parameterised notions of computation}, volume={19}, ISSN={0956-7968, 1469-7653}, DOI={10.1017/S095679680900728X}, abstractNote={Abstract

             Moggi’s Computational Monads and Power
             et al
             .’s equivalent notion of Freyd category have captured a large range of computational effects present in programming languages. Examples include non-termination, non-determinism, exceptions, continuations, side effects and input/output. We present generalisations of both computational monads and Freyd categories, which we call
             parameterised
             monads and
             parameterised
             Freyd categories, that also capture computational effects with parameters. Examples of such are composable continuations, side effects where the type of the state varies and input/output where the range of inputs and outputs varies. By considering structured parameterisation also, we extend the range of effects to cover separated side effects and multiple independent streams of I/O. We also present two typed λ-calculi that soundly and completely model our categorical definitions – with and without symmetric monoidal parameterisation – and act as prototypical languages with parameterised effects.}, number={3–4}, journal={Journal of Functional Programming}, author={Atkey, Robert}, year={2009}, month={Jul}, pages={335–376} }
@inproceedings{qtt, place={Oxford, United Kingdom}, series={LICS ’18}, title={Syntax and Semantics of Quantitative Type Theory}, ISBN={978-1-4503-5583-4}, url={https://doi.org/10.1145/3209108.3209189}, DOI={10.1145/3209108.3209189}, abstractNote={We present Quantitative Type Theory, a Type Theory that records usage information for each variable in a judgement, based on a previous system by McBride. The usage information is used to give a realizability semantics using a variant of Linear Combinatory Algebras, refining the usual realizability semantics of Type Theory by accurately tracking resource behaviour. We define the semantics in terms of Quantitative Categories with Families, a novel extension of Categories with Families for modelling resource sensitive type theories.}, booktitle={Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science}, publisher={Association for Computing Machinery}, author={Atkey, Robert}, year={2018}, month={Jul}, pages={56–65}, collection={LICS ’18} }
@article{computational_types, title={Computational types from a logical perspective}, volume={8}, ISSN={0956-7968, 1469-7653}, DOI={10.1017/S0956796898002998}, abstractNote={Moggi’s computational lambda calculus is a metalanguage for

enotational semantics which
rose from the observation that many different notions of computation have
the categorical
tructure of a strong monad on a cartesian closed category. In this paper
we show that
he computational lambda calculus also arises naturally as the term calculus
corresponding
by the Curry–Howard correspondence) to a novel intuitionistic modal
propositional logic.
e give natural deduction, sequent calculus and Hilbert-style presentations
of this logic and
rove strong normalisation and confluence results.}, number={2}, journal={Journal of Functional Programming}, author={Benton, P. N. and Bierman, G. M. and De Paiva, V. C. V.}, year={1998}, month={Mar}, pages={177–193} }
@article{linear_haskell, title={Linear Haskell: practical linearity in a higher-order polymorphic language}, url={https://doi.org/10.1145/3158093}, abstractNote={Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as OCaml or Haskell. In this paper, we study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear functions can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values. To demonstrate the efficacy of our linear type system — both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write programs with linear types — we implemented our type system in ghc, the leading Haskell compiler, and demonstrate two kinds of applications of linear types: mutable data with pure interfaces; and enforcing protocols in I/O-performing functions.}, publisher={Association for Computing Machinery}, author={Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud}, year={2017}, month={Dec} }
@article{idris1, title={Idris, a general-purpose dependently typed programming language: Design and implementation}, volume={23}, ISSN={0956-7968, 1469-7653}, DOI={10.1017/S095679681300018X}, abstractNote={Many components of a dependently typed programming language are by now well understood, for example, the underlying type theory, type checking, unification and evaluation. How to combine these components into a realistic and usable high-level language is, however, folklore, discovered anew by successive language implementors. In this paper, I describe the implementation of Idris, a new dependently typed functional programming language. Idris is intended to be a general-purpose programming language and as such provides high-level concepts such as implicit syntax, type classes and do notation. I describe the high-level language and the underlying type theory, and present a tactic-based method for elaborating concrete high-level syntax with implicit arguments and type classes into a fully explicit type theory. Furthermore, I show how this method facilitates the implementation of new high-level language constructs.}, number={5}, journal={Journal of Functional Programming}, author={Brady, Edwin}, year={2013}, month={Sep}, pages={552–593} }
@book{tdd, place={Shelter Island, NY}, title={Type-driven development with Idris}, ISBN={978-1-61729-302-3}, abstractNote={Introduction. Overview ; Getting started with Idris -- Core Idris. Interactive development with types ; User-defined data types ; Interactive programs : input and output processing ; Programming with first-class types ; Interfaces : using constrained generic types ; Equality : expressing relationships between data ; Predicates : expressing assumptions and contracts in types ; Views : extending pattern matching -- Idris and the real world. Streams and processes : working with infinite data ; Writing programs with state ; State machines L verifying protocols in types ; Dependent state machines : handling feedback and errors ; Type-safe concurrent programming}, publisher={Manning}, author={Brady, Edwin}, year={2017} }
@inbook{store_indices, place={Berlin, Heidelberg}, series={Lecture Notes in Computer Science}, title={Inductive Families Need Not Store Their Indices}, volume={3085}, ISBN={978-3-540-22164-7}, url={http://link.springer.com/10.1007/978-3-540-24849-1_8}, DOI={10.1007/978-3-540-24849-1_8}, booktitle={Types for Proofs and Programs}, publisher={Springer Berlin Heidelberg}, author={Brady, Edwin and McBride, Conor and McKinna, James}, editor={Berardi, Stefano and Coppo, Mario and Damiani, Ferruccio}, year={2004}, pages={115–129}, collection={Lecture Notes in Computer Science} }
@inbook{quantitative_coeffects, place={Berlin, Heidelberg}, series={Lecture Notes in Computer Science}, title={A Core Quantitative Coeffect Calculus}, volume={8410}, ISBN={978-3-642-54832-1}, url={http://link.springer.com/10.1007/978-3-642-54833-8_19}, DOI={10.1007/978-3-642-54833-8_19}, booktitle={Programming Languages and Systems}, publisher={Springer Berlin Heidelberg}, author={Brunel, Aloïs and Gaboardi, Marco and Mazza, Damiano and Zdancewic, Steve}, editor={Shao, Zhong}, year={2014}, pages={351–370}, collection={Lecture Notes in Computer Science} }
@article{levitation, title={The gentle art of levitation}, url={https://doi.org/10.1145/1932681.1863547}, abstractNote={We present a closed dependent type theory whose inductive types are given not by a scheme for generative declarations, but by encoding in a universe. Each inductive datatype arises by interpreting its description - a first-class value in a datatype of descriptions. Moreover, the latter itself has a description. Datatype-generic programming thus becomes ordinary programming. We show some of the resulting generic operations and deploy them in particular, useful ways on the datatype of datatype descriptions itself. Simulations in existing systems suggest that this apparently self-supporting setup is achievable without paradox or infinite regress.}, publisher={Association for Computing Machinery}, author={Chapman, James and Dagand, Pierre-Évariste and McBride, Conor and Morris, Peter}, year={2010}, month={Sep} }
@article{linear_ref_count, title={Reference counting as a computational interpretation of linear logic}, volume={6}, ISSN={1469-7653, 0956-7968}, DOI={10.1017/S0956796800001660}, abstractNote={We develop an operational model for a language based on linear logic. Our semantics is ‘low-level’ enough to express sharing and copying while still being ‘high-level’ enough to abstract away from details of memory layout, and thus can be used to test potential applications of linear logic for analysis of programs. In particular, we demonstrate a precise relationship between type correctness for the linear-logic-based language and the correctness of a reference-counting interpretation of the primitives, and formulate and prove a result describing the possible run-time reference counts of values of linear type.}, number={2}, journal={Journal of Functional Programming}, author={Chirimar, Jawahar and Gunter, Carl A. and Riecke, Jon G.}, year={1996}, month={Mar}, pages={195–244} }
@article{functions_ornaments, title={Transporting functions across ornaments}, volume={47}, ISSN={0362-1340, 1558-1160}, DOI={10.1145/2398856.2364544}, number={9}, journal={ACM SIGPLAN Notices}, author={Dagand, Pierre-Evariste and McBride, Conor}, year={2012}, month={Oct}, pages={103–114} }
@article{monad_or_comonad, title={Should I use a Monad or a Comonad}, url={https://www.cs.kent.ac.uk/people/staff/dao7/drafts/monad-or-comonad-orchard11-draft.pdf}, abstractNote={The category theoretic structures of monads and comonads can be used as an abstraction mechanism for simplifying both language semantics and programs. Monads have been used to structure impure computations, whilst comonads have been used to structure context-dependent computations. Interestingly, the class of computations structured by monads and the class of computations structured by comonads are not mutually exclusive. This paper formalises and explores the conditions under which a monad and a comonad can both structure the same notion of computation: when a comonad is left adjoint to a monad. Furthermore, we examine situations where a particular monad/comonad model of computation is deficient in capturing the essence of a computational pattern and provide a technique for calculating an alternative monad or comonad structure which fully captures the essence of the computation. Included is some discussion on how to choose between a monad or comonad structure in the case where either can be used to capture a particular notion of computation.}, author={Dominic Orchard}, year={2012} }
@inproceedings{state_machines, series={ML 2017}, title={State machines all the way down}, abstractNote={A useful pattern in dependently typed programming is to define a state transition system, for example the states and operations in a network protocol, as an indexed monad. We index each operation by its input and output states, thus guaranteeing that operations satisfy pre- and post-conditions, by typechecking. However, what if we want to write a program using several systems at once? What if we want to define a high level state transition system, such as a network application protocol, in terms of lower level states, such as network sockets and mutable variables?

n this talk, I will present an architecture for dependently typed applications based on a hierarchy of state transition systems, implemented in a generic data type ST. This is based on a monad indexed by contexts of resources, allowing us to reason about multiple state transition systems in the type of a function. Using ST, we show: how to implement a state transition system as a dependent type, with type level guarantees on its operations; how to account for operations which could fail; how to combine state transition systems into a larger system; and, how to implement larger systems as a hierarchy of state transition systems. I will illustrate the system with a high level network application protocol, implemented in terms of POSIX network sockets.}, author={Edwin Brady}, year={2017}, month={Sep}, collection={ML 2017} }
@article{linear_diff, title={Linear dependent types for differential privacy}, volume={48}, ISSN={0362-1340, 1558-1160}, DOI={10.1145/2480359.2429113}, number={1}, journal={ACM SIGPLAN Notices}, author={Gaboardi, Marco and Haeberlen, Andreas and Hsu, Justin and Narayan, Arjun and Pierce, Benjamin C.}, year={2013}, month={Jan}, pages={357–370} }
@article{effect_coeffects_grading, title={Combining effects and coeffects via grading}, volume={51}, ISSN={0362-1340, 1558-1160}, DOI={10.1145/3022670.2951939}, number={9}, journal={ACM SIGPLAN Notices}, author={Gaboardi, Marco and Katsumata, Shin-ya and Orchard, Dominic and Breuvart, Flavien and Uustalu, Tarmo}, year={2016}, month={Dec}, pages={476–489} }
@book{typed_lambda, place={Berlin, Heidelberg}, title={Typed Lambda Calculi and Applications 6th International Conference, TLCA 2003 Valencia, Spain, June 10-12, 2003 Proceedings}, ISBN={978-3-540-44904-1}, publisher={Springer-Verlag Berlin Heidelberg}, author={Hofmann, Martin}, year={2003} }
@inproceedings{parametric_effects, place={San Diego, California, USA}, title={Parametric effect monads and semantics of effect systems}, ISBN={978-1-4503-2544-8}, url={http://dl.acm.org/citation.cfm?doid=2535838.2535846}, DOI={10.1145/2535838.2535846}, booktitle={Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL ’14}, publisher={ACM Press}, author={Katsumata, Shin-ya}, year={2014}, pages={633–645} }
@inproceedings{hasochism, place={Boston, Massachusetts, USA}, series={Haskell ’13}, title={Hasochism: the pleasure and pain of dependently typed haskell programming}, ISBN={978-1-4503-2383-3}, url={https://doi.org/10.1145/2503778.2503786}, DOI={10.1145/2503778.2503786}, abstractNote={Haskell’s type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples---merge-sort and rectangular tilings---we show how to exploit Haskell’s constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.}, booktitle={Proceedings of the 2013 ACM SIGPLAN symposium on Haskell}, publisher={Association for Computing Machinery}, author={Lindley, Sam and McBride, Conor}, year={2013}, month={Sep}, pages={81–92}, collection={Haskell ’13} }
@book{Martin-Lof, title={An intuitionistic theory of types}, abstractNote={An earlier, not yet conclusive, attempt at formulating a theory of this kind was made by Scott 1970. Also related, although less closely, are the type and logic free theories of constructions of Kreisel 1962 and 1965 and Goodman 1970. In its first version, the present theory was based on the strongly impredicative axiom that there is a type of all types whatsoever, which is at the same time a type and an object of that type. This axiom had to be abandoned, however, after it was shown to lead to a contradiction by Jean Yves Girard. I am very grateful to him for showing me his paradox. The change that it necessitated is so drastic that my theory no longer contains intuitionistic simple type theory as it originally did. Instead, its proof theoretic strength should be close to that of predicative analysis.}, author={Martin-Löf, Per} }
@inproceedings{rust, place={Portland, Oregon, USA}, title={The rust language}, ISBN={978-1-4503-3217-0}, url={http://dl.acm.org/citation.cfm?doid=2663171.2663188}, DOI={10.1145/2663171.2663188}, booktitle={Proceedings of the 2014 ACM SIGAda annual conference on High integrity language technology - HILT ’14}, publisher={ACM Press}, author={Matsakis, Nicholas D. and Klock, Felix S.}, year={2014}, pages={103–104} }
@article{linear_inference, title={Modular Inference of Linear Types for Multiplicity-Annotated Arrows}, url={http://arxiv.org/abs/1911.00268}, abstractNote={Bernardy et al. [2018] proposed a linear type system $lambda^q_to$ as a core type system of Linear Haskell. In the system, linearity is represented by annotated arrow types $A to_m B$, where $m$ denotes the multiplicity of the argument. Thanks to this representation, existing non-linear code typechecks as it is, and newly written linear code can be used with existing non-linear code in many cases. However, little is known about the type inference of $lambda^q_to$. Although the Linear Haskell implementation is equipped with type inference, its algorithm has not been formalized, and the implementation often fails to infer principal types, especially for higher-order functions. In this paper, based on OutsideIn(X) [Vytiniotis et al., 2011], we propose an inference system for a rank 1 qualified-typed variant of $lambda^q_to$, which infers principal types. A technical challenge in this new setting is to deal with ambiguous types inferred by naive qualified typing. We address this ambiguity issue through quantifier elimination and demonstrate the effectiveness of the approach with examples.}, note={arXiv: 1911.00268}, journal={arXiv:1911.00268 [cs]}, author={Matsuda, Kazutaka}, year={2020}, month={Feb} }
@article{invertible_functions, title={Sparcl: a language for partially-invertible computation}, volume={4}, ISSN={2475-1421, 2475-1421}, DOI={10.1145/3409000}, number={ICFP}, journal={Proceedings of the ACM on Programming Languages}, author={Matsuda, Kazutaka and Wang, Meng}, year={2020}, month={Aug}, pages={1–31} }
@article{clowns_and_jokers, title={Clowns to the left of me, jokers to the right (pearl): dissecting data structures}, url={https://doi.org/10.1145/1328897.1328474}, abstractNote={This paper introduces a small but useful generalisation to the “derivative” operation on datatypes underlying Huet’s notion of “zipper”, giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, “dissection”, turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right. I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet’s operations for navigating zippers. The original motivation for dissection was to define “division”, capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online and compiles with recent extensions to the Glasgow Haskell Compiler.}, publisher={Association for Computing Machinery}, author={McBride, Conor}, year={2008}, month={Jan} }
@article{view_from_the_left, title={The view from the left}, volume={14}, ISSN={1469-7653, 0956-7968}, DOI={10.1017/S0956796803004829}, abstractNote={Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler’s (1987) notion of ‘view’. The programmer wishing to introduce a new view of a type $mathit{T}$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry–Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for $mathit{T}$. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.}, number={1}, journal={Journal of Functional Programming}, author={Mcbride, Conor and Mckinna, James}, year={2004}, month={Jan}, pages={69–111} }
@book{agda, place={Göteborg}, series={Doktorsavhandlingar vid Chalmers Tekniska Högskola}, title={Towards a practical programming language based on dependent type theory}, ISBN={978-91-7291-996-9}, publisher={Chalmers Univ. of Technology}, author={Norell, Ulf}, year={2007}, collection={Doktorsavhandlingar vid Chalmers Tekniska Högskola} }
@inproceedings{agda_programming, place={Savannah, GA, USA}, title={Dependently typed programming in Agda}, ISBN={978-1-60558-420-1}, url={http://portal.acm.org/citation.cfm?doid=1481861.1481862}, DOI={10.1145/1481861.1481862}, booktitle={Proceedings of the 4th international workshop on Types in language design and implementation - TLDI ’09}, publisher={ACM Press}, author={Norell, Ulf}, year={2008}, pages={1–2} }
@inproceedings{agda_interactive, place={Boston, Massachusetts, USA}, title={Interactive programming with dependent types}, ISBN={978-1-4503-2326-0}, url={http://dl.acm.org/citation.cfm?doid=2500365.2500610}, DOI={10.1145/2500365.2500610}, booktitle={Proceedings of the 18th ACM SIGPLAN international conference on Functional programming - ICFP ’13}, publisher={ACM Press}, author={Norell, Ulf}, year={2013}, pages={1} }
@article{granule, title={Quantitative program reasoning with graded modal types}, volume={3}, ISSN={2475-1421, 2475-1421}, DOI={10.1145/3341714}, number={ICFP}, journal={Proceedings of the ACM on Programming Languages}, author={Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley}, year={2019}, month={Jul}, pages={1–30} }
@article{monads_and_effects, title={The semantic marriage of monads and effects}, url={http://arxiv.org/abs/1401.5391}, abstractNote={Wadler and Thiemann unified type-and-effect systems with monadic semantics via a syntactic correspondence and soundness results with respect to an operational semantics. They conjecture that a general, “coherent” denotational semantics can be given to unify effect systems with a monadic-style semantics. We provide such a semantics based on the novel structure of an indexed monad, which we introduce. We redefine the semantics of Moggi’s computational lambda-calculus in terms of (strong) indexed monads which gives a one-to-one correspondence between indices of the denotations and the effect annotations of traditional effect systems. Dually, this approach yields indexed comonads which gives a unified semantics and effect system to contextual notions of effect (called coeffects), which we have previously described.}, note={arXiv: 1401.5391}, journal={arXiv:1401.5391 [cs]}, author={Orchard, Dominic and Petricek, Tomas and Mycroft, Alan}, year={2014}, month={Jan} }
@article{coeffect_computation, title={Coeffects: a calculus of context-dependent computation}, volume={49}, ISSN={0362-1340, 1558-1160}, DOI={10.1145/2692915.2628160}, number={9}, journal={ACM SIGPLAN Notices}, author={Petricek, Tomas and Orchard, Dominic and Mycroft, Alan}, year={2014}, month={Nov}, pages={123–135} }
@article{linear_types_update, title={Linear types can change the world!}, url={https://homepages.inf.ed.ac.uk/wadler/papers/linear/linear.ps}, author={Philip Wadler}, year=1990}
@article{linear_types_session, title={Propositions as sessions}, url={https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions-jfp.pdf}, author={Philip Wadler}, year={2012}}
@article{linear_types_subst, title={There is no substitute for linear logic}, url={https://homepages.inf.ed.ac.uk/wadler/papers/linearsub/linearsub.ps}, author={Philip Wadler}, year={2003}}
@article{monad_and_comonad, title={Combining a monad and a comonad}, volume={280}, ISSN={03043975}, DOI={10.1016/S0304-3975(01)00024-X}, number={1–2}, journal={Theoretical Computer Science}, author={Power, John and Watanabe, Hiroshi}, year={2002}, month={May}, pages={137–162} }
@article{actor_channels, title={Mixing Metaphors: Actors as Channels and Channels as Actors}, url={https://homepages.inf.ed.ac.uk/wadler/papers/mixing-metaphors/mixing-metaphors.pdf}, author={Simon Fowler and Sam Lindley and Philip Wadler}, year={2017}}
@article{graded_monads_rings, title={Graded monads and rings of polynomials}, volume={151}, ISSN={1072-3374, 1573-8795}, DOI={10.1007/s10958-008-9013-7}, number={3}, journal={Journal of Mathematical Sciences}, author={Smirnov, A. L.}, year={2008}, month={Jun}, pages={3032–3051} }
@article{cartographer, title={CARTOGRAPHER: A Tool for String Diagrammatic Reasoning (Tool Paper)}, DOI={10.4230/LIPICS.CALCO.2019.20}, publisher={Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany}, author={Sobocinski, Pawel and Wilson, Paul W. and Zanasi, Fabio}, year={2019}, pages={7 pages} }
@article{affine_types, title={Practical affine types}, url={https://doi.org/10.1145/1925844.1926436}, abstractNote={Alms is a general-purpose programming language that supports practical affine types. To offer the expressiveness of Girard’s linear logic while keeping the type system light and convenient, Alms uses expressive kinds that minimize notation while maximizing polymorphism between affine and unlimited types. A key feature of Alms is the ability to introduce abstract affine types via ML-style signature ascription. In Alms, an interface can impose stiffer resource usage restrictions than the principal usage restrictions of its implementation. This form of sealing allows the type system to naturally and directly express a variety of resource management protocols from special-purpose type systems. We present two pieces of evidence to demonstrate the validity of our design goals. First, we introduce a prototype implementation of Alms and discuss our experience programming in the language. Second, we establish the soundness of the core language. We also use the core model to prove a principal kinding theorem.}, publisher={Association for Computing Machinery}, author={Tov, Jesse A. and Pucella, Riccardo}, year={2011}, month={Jan} }
@article{immutable_beans, title={Counting Immutable Beans: Reference Counting Optimized for Purely Functional Programming}, url={http://arxiv.org/abs/1908.05647}, abstractNote={Most functional languages rely on some garbage collection for automatic memory management. They usually eschew reference counting in favor of a tracing garbage collector, which has less bookkeeping overhead at runtime. On the other hand, having an exact reference count of each value can enable optimizations, such as destructive updates. We explore these optimization opportunities in the context of an eager, purely functional programming language. We propose a new mechanism for efficiently reclaiming memory used by nonshared values, reducing stress on the global memory allocator. We describe an approach for minimizing the number of reference counts updates using borrowed references and a heuristic for automatically inferring borrow annotations. We implemented all these techniques in a new compiler for an eager and purely functional programming language with support for multi-threading. Our preliminary experimental results demonstrate our approach is competitive and often outperforms state-of-the-art compilers.}, note={arXiv: 1908.05647}, journal={arXiv:1908.05647 [cs]}, author={Ullrich, Sebastian and de Moura, Leonardo}, year={2020}, month={Mar} }
@article{cubical_agda, title={Cubical agda: a dependently typed programming language with univalence and higher inductive types}, url={https://doi.org/10.1145/3341691}, abstractNote={Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.}, publisher={Association for Computing Machinery}, author={Vezzosi, Andrea and Mörtberg, Anders and Abel, Andreas}, year={2019}, month={Jul} }
@article{linear_use, title={Is there a use for linear logic?}, url={https://doi.org/10.1145/115866.115894}, publisher={Association for Computing Machinery}, author={Wadler, Philip}, year={1991}, month={May} }
@inproceedings{linear_race,  title     = "Towards Races in Linear Logic",  abstract  = "Process calculi based in logic, such as ÏDILL and CP, provide a foundation for deadlock-free concurrent programming, but exclude nondeterminism and races. HCP is a reformulation of CP which addresses a fundamental shortcoming: the fundamental operator for parallel composition from the Ï-calculus does not correspond to any rule of linear logic, and therefore not to any term construct in CP. We introduce HCPâ ND, which extends HCP with a novel account of nondeterminism. Our approach draws on bounded linear logic to provide a strongly-typed account of standard process calculus expressions of non-determinism. We show that our extension is expressive enough to capture many uses of non-determinism in untyped calculi, such as nondeterministic choice, while preserving HCP{\textquoteright}s meta-theoretic properties, including deadlock freedom. ",  keywords  = "Ï -calculus, Linear logic, Session types, Non-determinism, Deadlock freedom",  author    = "Kerewin Kokke and Morris, {J. Garrett} and Philip Wadler",  year      = "2019",  month     = aug,  day       = "8",  doi       = "10.1007/978-3-030-22397-7_3",  language  = "English",  isbn      = "978-3-030-22396-0",  volume    = "11533",  series    = "Lecture Notes in Computer Science",  publisher = "Springer, Cham",  pages     = "37--53",  editor    = "{Riis Nielson}, Hanne and Emilio Tuosto",  booktitle = "Coordination Models and Languages",  note      = "21st IFIP WG 6.1 International Conference, COORDINATION 2019, International Conference on Coordination Models and Languages : Held as Part of the 14th International Federated Conference on Distributed Computing Techniques, DisCoTec 2019, Kongens Lyngby, Denmark, June 17â21, 2019, COORDINATION 2019 ; Conference date: 17-06-2019 Through 21-06-2019",  url       = "http://www.discotec.org/2019/coordination", }
@inproceedings{lightweight_linear_types, place={Madrid, Spain}, title={Lightweight linear types in system f°}, ISBN={978-1-60558-891-9}, url={http://portal.acm.org/citation.cfm?doid=1708016.1708027}, DOI={10.1145/1708016.1708027}, booktitle={Proceedings of the 5th ACM SIGPLAN workshop on Types in language design and implementation - TLDI ’10}, publisher={ACM Press}, author={Mazurak, Karl and Zhao, Jianzhou and Zdancewic, Steve}, year={2010}, pages={77} }
@inproceedings{integrating_linear_dependent, place={Mumbai, India}, title={Integrating Linear and Dependent Types}, ISBN={978-1-4503-3300-9}, url={http://dl.acm.org/citation.cfm?doid=2676726.2676969}, DOI={10.1145/2676726.2676969}, booktitle={Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL ’15}, publisher={ACM Press}, author={Krishnaswami, Neelakantan R. and Pradic, Pierre and Benton, Nick}, year={2015}, pages={17–30} }
@inproceedings{once_upon_a_type,
  title={Once upon a type},
  author={Turner, David N and Wadler, Philip and Mossin, Christian},
  booktitle={Proceedings of the seventh international conference on Functional programming languages and computer architecture},
  pages={1--11},
  year={1995}
}
@inproceedings{deforestation,
  title={Deforestation: Transforming programs to eliminate trees},
  author={Wadler, Philip},
  booktitle={European Symposium on Programming},
  pages={344--358},
  year={1988},
  organization={Springer}
}
@inproceedings{linear-logic,
  title={Theoretical computer science},
  author={Girard, Jean-Yves},
  booktitle={Linear logic},
  volume={50},
  pages={1--102},
  year={1987}
}
@article{bll,
  title={Bounded linear logic: a modular approach to polynomial-time computability},
  author={Girard, Jean-Yves and Scedrov, Andre and Scott, Philip J},
  journal={Theoretical computer science},
  volume={97},
  number={1},
  pages={1--66},
  year={1992},
  publisher={Elsevier}
}
@book{typedefs, title={Typedefs}, url={https://typedefs.com}, author={Statebox} }
@article{idris-ct, title={idris-ct: A Library to do Category Theory in Idris}, volume={323}, ISSN={2075-2180}, DOI={10.4204/EPTCS.323.16}, abstractNote={We introduce idris-ct, a Idris library providing verified type definitions of categorical concepts.idris-ct strives to be a bridge between academy and industry, catering both to category theorists who want to implement and try their ideas in a practical environment and to businesses and engineers who care about formalization with category theory: It is inspired by similar libraries developed for theorem proving but remains very practical, being aimed at software production in business. Nevertheless, the use of dependent types allows for a formally correct implementation of categorical concepts, so that guarantees can be made on software properties.}, note={arXiv: 1912.06191}, journal={Electronic Proceedings in Theoretical Computer Science}, author={Genovese, Fabrizio and Gryzlov, Alex and Herold, Jelle and Knispel, Andre and Perone, Marco and Post, Erik and Videla, André}, year={2020}, month={Sep}, pages={246–254} }
@article{petri-nets, title={The Essence of Petri Net Gluings}, url={http://arxiv.org/abs/1909.03518}, abstractNote={Many categorical frameworks have been proposed to formalize the idea of gluing Petri nets with each other. Such frameworks model net gluings in terms of sharing of resources or synchronization of transitions. Interpretations given to these gluings are more or less satisfactory when we consider Petri nets with a semantics attached to them. In this work, we define a framework to compose Petri nets together in such a way that their semantics is respected. In addition to this, we show how our framework generalizes the previously defined ones.}, note={arXiv: 1909.03518}, journal={arXiv:1909.03518 [cs, math]}, author={Genovese, Fabrizio}, year={2019}, month={Sep} }
@inbook{nuttin, place={Cham}, series={Lecture Notes in Computer Science}, title={I Got Plenty o’ Nuttin’}, volume={9600}, ISBN={978-3-319-30935-4}, url={http://link.springer.com/10.1007/978-3-319-30936-1_12}, DOI={10.1007/978-3-319-30936-1_12}, booktitle={A List of Successes That Can Change the World}, publisher={Springer International Publishing}, author={McBride, Conor}, editor={Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don}, year={2016}, pages={207–233}, collection={Lecture Notes in Computer Science} }
@inbook{nofib, place={London}, series={Workshops in Computing}, title={The nofib Benchmark Suite of Haskell Programs}, ISBN={978-3-540-19820-8}, url={http://link.springer.com/10.1007/978-1-4471-3215-8_17}, DOI={10.1007/978-1-4471-3215-8_17}, booktitle={Functional Programming, Glasgow 1992}, publisher={Springer London}, author={Partain, Will}, editor={Launchbury, John and Sansom, Patrick}, year={1993}, pages={195–202}, collection={Workshops in Computing} }
@inproceedings{dependent_graded, series={TyDe 2020}, title={Graded Modal Dependent Type Theory}, url={https://icfp20.sigplan.org/details/tyde-2020-papers/5/Graded-Modal-Dependent-Type-Theory-Extended-Abstract-}, abstractNote={We introduce a novel dependent type theory called Graded Modal Dependent Type Theory (GrTT) that provides a new solution to the long-standing challenge of how to combine linear logic and dependent types. The key to reconciling these two notions is to leverage the recent approach of graded types, which treats data as a resource which is subject to fine-grained, quantitative tracking in the type system. GrTT offers fine-grained control over resource usage at both the runtime value level and the type level. We argue that the combination of linearity, graded modalities, and dependent types provides a rich language for specifying and reasoning about dependently-typed programs in a more fine-grained way than current approaches, enabling precise reasoning about usage information on compound data in a dependently-typed setting.}, author={Benjamin Moon, Harley D. Eades III, Dominic Orchard}, year={2020}, month={Aug}, collection={TyDe 2020} }

